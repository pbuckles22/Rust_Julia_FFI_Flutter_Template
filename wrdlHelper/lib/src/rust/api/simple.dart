// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// * Greet a user with a personalized message
/// *
/// * This function demonstrates basic string handling across the FFI boundary.
/// * It takes a name parameter and returns a formatted greeting string.
/// *
/// * # Arguments
/// * - `name`: The name of the person to greet
/// *
/// * # Returns
/// * A formatted greeting string
/// *
/// * # Example
/// * ```rust
/// * let greeting = greet("Alice".to_string());
/// * assert_eq!(greeting, "Hello, Alice!");
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(n) where n is the length of the name
///
String greet({required String name}) =>
    RustLib.instance.api.crateApiSimpleGreet(name: name);

/// * Add two integers and return the result
/// *
/// * Demonstrates basic arithmetic operations across the FFI boundary.
/// * This function showcases how to handle primitive types in FFI calls.
/// *
/// * # Arguments
/// * - `a`: First integer
/// * - `b`: Second integer
/// *
/// * # Returns
/// * The sum of a and b
/// *
/// * # Example
/// * ```rust
/// * let result = add_numbers(5, 3);
/// * assert_eq!(result, 8);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(1)
///
int? addNumbers({required int a, required int b}) =>
    RustLib.instance.api.crateApiSimpleAddNumbers(a: a, b: b);

/// * Multiply two floating-point numbers
/// *
/// * Demonstrates floating-point arithmetic across the FFI boundary.
/// * Useful for mathematical computations that need to be performed in Rust
/// * for performance reasons.
/// *
/// * # Arguments
/// * - `a`: First floating-point number
/// * - `b`: Second floating-point number
/// *
/// * # Returns
/// * The product of a and b
/// *
/// * # Example
/// * ```rust
/// * let result = multiply_floats(2.5, 4.0);
/// * assert_eq!(result, 10.0);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(1)
///
double multiplyFloats({required double a, required double b}) =>
    RustLib.instance.api.crateApiSimpleMultiplyFloats(a: a, b: b);

/// * Check if a number is even
/// *
/// * Demonstrates boolean return types across the FFI boundary.
/// * This function showcases conditional logic and boolean operations.
/// *
/// * # Arguments
/// * - `number`: The integer to check
/// *
/// * # Returns
/// * `true` if the number is even, `false` otherwise
/// *
/// * # Example
/// * ```rust
/// * assert!(is_even(4));
/// * assert!(!is_even(3));
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(1)
///
bool isEven({required int number}) =>
    RustLib.instance.api.crateApiSimpleIsEven(number: number);

/// * Get current timestamp as milliseconds since Unix epoch
/// *
/// * Demonstrates system time access across the FFI boundary.
/// * This function can be useful for logging, caching, or time-based operations.
/// *
/// * # Returns
/// * Current timestamp in milliseconds since Unix epoch
/// *
/// * # Example
/// * ```rust
/// * let timestamp = get_current_timestamp();
/// * assert!(timestamp > 0);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(1)
/// *
/// * # Errors
/// * This function can panic if the system time is before Unix epoch,
/// * which is extremely unlikely in practice.
///
BigInt getCurrentTimestamp() =>
    RustLib.instance.api.crateApiSimpleGetCurrentTimestamp();

/// * Process a list of strings and return their lengths
/// *
/// * Demonstrates vector/array handling across the FFI boundary.
/// * This function showcases how to work with collections in FFI calls.
/// *
/// * # Arguments
/// * - `strings`: Vector of strings to process
/// *
/// * # Returns
/// * Vector of string lengths
/// *
/// * # Example
/// * ```rust
/// * let strings = vec!["hello".to_string(), "world".to_string()];
/// * let lengths = get_string_lengths(strings);
/// * assert_eq!(lengths, vec![5, 5]);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(n) where n is the number of strings
/// * - Space complexity: O(n) for the result vector
///
Uint32List getStringLengths({required List<String> strings}) =>
    RustLib.instance.api.crateApiSimpleGetStringLengths(strings: strings);

/// * Create a simple key-value mapping
/// *
/// * Demonstrates HashMap handling across the FFI boundary.
/// * This function showcases how to work with complex data structures in FFI calls.
/// *
/// * # Arguments
/// * - `pairs`: Vector of (key, value) tuples
/// *
/// * # Returns
/// * HashMap containing the key-value pairs
/// *
/// * # Example
/// * ```rust
/// * let pairs = vec![("name".to_string(), "Alice".to_string())];
/// * let map = create_string_map(pairs);
/// * assert_eq!(map.get("name"), Some(&"Alice".to_string()));
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(n) where n is the number of pairs
/// * - Space complexity: O(n) for the HashMap
///
Map<String, String> createStringMap({required List<(String, String)> pairs}) =>
    RustLib.instance.api.crateApiSimpleCreateStringMap(pairs: pairs);

/// * Calculate the factorial of a number
/// *
/// * Demonstrates recursive algorithms across the FFI boundary.
/// * This function showcases mathematical computations that can benefit
/// * from Rust's performance characteristics.
/// *
/// * # Arguments
/// * - `n`: The number to calculate factorial for (must be >= 0)
/// *
/// * # Returns
/// * The factorial of n
/// *
/// * # Example
/// * ```rust
/// * assert_eq!(factorial(5), 120);
/// * assert_eq!(factorial(0), 1);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(n)
/// * - Space complexity: O(n) due to recursion
/// *
/// * # Panics
/// * This function will panic if n is negative due to integer overflow.
/// * In a production environment, consider using a Result type instead.
///
int factorial({required int n}) =>
    RustLib.instance.api.crateApiSimpleFactorial(n: n);

/// * Check if a string is a palindrome
/// *
/// * Demonstrates string manipulation and algorithm implementation
/// * across the FFI boundary. This function showcases text processing
/// * capabilities that can be efficiently implemented in Rust.
/// *
/// * # Arguments
/// * - `text`: The string to check
/// *
/// * # Returns
/// * `true` if the string is a palindrome, `false` otherwise
/// *
/// * # Example
/// * ```rust
/// * assert!(is_palindrome("racecar".to_string()));
/// * assert!(!is_palindrome("hello".to_string()));
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(n) where n is the length of the string
/// * - Space complexity: O(1) for the optimized version
/// *
/// * # Note
/// * This implementation is case-sensitive and does not ignore whitespace.
/// * For a more robust implementation, consider normalizing the input.
///
bool isPalindrome({required String text}) =>
    RustLib.instance.api.crateApiSimpleIsPalindrome(text: text);

/// * Generate a simple hash for a string
/// *
/// * Demonstrates hashing algorithms across the FFI boundary.
/// * This function showcases cryptographic or data integrity operations
/// * that can be efficiently implemented in Rust.
/// *
/// * # Arguments
/// * - `input`: The string to hash
/// *
/// * # Returns
/// * A simple hash value as u32
/// *
/// * # Example
/// * ```rust
/// * let hash1 = simple_hash("hello".to_string());
/// * let hash2 = simple_hash("hello".to_string());
/// * assert_eq!(hash1, hash2);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(n) where n is the length of the string
/// * - Space complexity: O(1)
/// *
/// * # Security Note
/// * This is a simple hash function for demonstration purposes.
/// * For cryptographic applications, use a proper hash function like SHA-256.
///
int simpleHash({required String input}) =>
    RustLib.instance.api.crateApiSimpleSimpleHash(input: input);

/// * Initialize word lists in Rust (call once at startup)
/// *
/// * This function loads word lists into Rust memory to avoid passing large
/// * data structures across the FFI boundary on every call.
///
void initializeWordLists() =>
    RustLib.instance.api.crateApiSimpleInitializeWordLists();

/// * Load word lists from Dart to Rust (call after Dart loads word lists)
/// *
/// * This function receives the actual word lists from Dart and stores them in Rust
/// * for optimal performance. This replaces the hardcoded 18 words with the full
/// * 15k+ word lists.
/// *
/// * # Arguments
/// * - `answer_words`: The 2,315 answer words from official_wordle_words.json
/// * - `guess_words`: The 14,854+ guess words from official_guess_words.txt
/// *
/// * # Performance
/// * - This is called once at startup after Dart loads the word lists
/// * - Subsequent calls to get_intelligent_guess_fast() will use these full lists
///
void loadWordListsFromDart({
  required List<String> answerWords,
  required List<String> guessWords,
}) => RustLib.instance.api.crateApiSimpleLoadWordListsFromDart(
  answerWords: answerWords,
  guessWords: guessWords,
);

/// * Get intelligent guess using advanced algorithms (optimized version)
/// *
/// * This function uses the wrdlHelper intelligent solver with Rust-managed word lists
/// * to avoid passing large data structures across FFI. Much faster than the original.
/// *
/// * # Arguments
/// * - `remaining_words`: Words that are still possible given current constraints
/// * - `guess_results`: Previous guess results with patterns
/// *
/// * # Returns
/// * The best word to guess next, or None if no valid guesses remain
/// *
/// * # Performance
/// * - Time complexity: O(n*m) where n is candidate words, m is remaining words
/// * - Space complexity: O(n) for pattern analysis
/// * - Target response time: < 200ms (much faster with Rust-managed words)
///
String? getIntelligentGuessFast({
  required List<String> remainingWords,
  required List<(String, List<String>)> guessResults,
}) => RustLib.instance.api.crateApiSimpleGetIntelligentGuessFast(
  remainingWords: remainingWords,
  guessResults: guessResults,
);

/// * Get the optimal first guess (pre-computed at startup)
/// *
/// * This function returns the optimal first guess that was computed once at startup.
/// * This avoids the expensive computation of analyzing all 14,854 words for the first guess.
/// *
/// * # Returns
/// * The optimal first guess word, or None if not computed yet
/// *
/// * # Performance
/// * - Time complexity: O(1) - just a lookup
/// * - Space complexity: O(1) - cached value
/// * - Target response time: < 1ms
///
String? getOptimalFirstGuess() =>
    RustLib.instance.api.crateApiSimpleGetOptimalFirstGuess();

/// * Get intelligent word suggestion using advanced algorithms
/// *
/// * This function uses Shannon entropy analysis, statistical analysis, and
/// * look-ahead strategy to recommend the optimal word for the current game state.
/// *
/// * # Arguments
/// * - `all_words`: Complete list of valid words
/// * - `remaining_words`: Words that could still be the answer
/// * - `guess_results`: Previous guess results with patterns
/// *
/// * # Returns
/// * The best word to guess next, or None if no valid suggestions
/// *
/// * # Performance
/// * - Time complexity: O(n*m) where n is candidate words, m is remaining words
/// * - Space complexity: O(n) for pattern analysis
/// * - Target response time: < 200ms
///
String? getIntelligentGuess({
  required List<String> allWords,
  required List<String> remainingWords,
  required List<(String, List<String>)> guessResults,
}) => RustLib.instance.api.crateApiSimpleGetIntelligentGuess(
  allWords: allWords,
  remainingWords: remainingWords,
  guessResults: guessResults,
);

/// * Filter words based on guess results
/// *
/// * This function filters a word list based on previous guess results,
/// * removing words that don't match the established patterns.
/// *
/// * # Arguments
/// * - `words`: List of words to filter
/// * - `guess_results`: Previous guess results with patterns
/// *
/// * # Returns
/// * Filtered list of words that match all patterns
/// *
/// * # Performance
/// * - Time complexity: O(n*m) where n is words, m is guess results
/// * - Space complexity: O(n) for filtered results
///
List<String> filterWords({
  required List<String> words,
  required List<(String, List<String>)> guessResults,
}) => RustLib.instance.api.crateApiSimpleFilterWords(
  words: words,
  guessResults: guessResults,
);

/// * Calculate entropy for a candidate word
/// *
/// * This function calculates the Shannon entropy (information gain) for a
/// * candidate word against the remaining possible words.
/// *
/// * # Arguments
/// * - `candidate_word`: The word to analyze
/// * - `remaining_words`: Words that could still be the answer
/// *
/// * # Returns
/// * Entropy value (higher = more information)
/// *
/// * # Performance
/// * - Time complexity: O(n) where n is remaining words
/// * - Space complexity: O(n) for pattern grouping
///
double calculateEntropy({
  required String candidateWord,
  required List<String> remainingWords,
}) => RustLib.instance.api.crateApiSimpleCalculateEntropy(
  candidateWord: candidateWord,
  remainingWords: remainingWords,
);

/// * Simulate guess pattern for testing
/// *
/// * This function simulates what pattern would result from guessing
/// * a word against a target word.
/// *
/// * # Arguments
/// * - `guess`: The word being guessed
/// * - `target`: The target word
/// *
/// * # Returns
/// * Pattern string like "GGYXY" (G=Green, Y=Yellow, X=Gray)
/// *
/// * # Performance
/// * - Time complexity: O(1) for 5-letter words
/// * - Space complexity: O(1)
///
String simulateGuessPattern({required String guess, required String target}) =>
    RustLib.instance.api.crateApiSimpleSimulateGuessPattern(
      guess: guess,
      target: target,
    );
