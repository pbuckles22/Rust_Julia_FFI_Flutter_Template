// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_candidate_words`, `get_top_strategic_words`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `SolverConfig`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WordManager>>
abstract class WordManager implements RustOpaqueInterface {
  List<String> get answerWords;

  List<String> get guessWords;

  String? get optimalFirstGuess;

  set answerWords(List<String> answerWords);

  set guessWords(List<String> guessWords);

  set optimalFirstGuess(String? optimalFirstGuess);

  /// Compute the optimal first guess once at startup
  ///
  /// Uses proven optimal first guesses from statistical analysis.
  /// No computation needed - these are already known to be optimal!
  Future<void> computeOptimalFirstGuess();

  Future<void> getAnswerWords();

  Future<void> getGuessWords();

  Future<String?> getOptimalFirstGuess();

  Future<void> loadWords();

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<WordManager> newInstance() =>
      RustLib.instance.api.crateApiWrdlHelperWordManagerNew();
}

/// FFI-compatible struct for guess results
class GuessResult {
  const GuessResult({required this.word, required this.results});
  final String word;
  final List<LetterResult> results;

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<GuessResult> newInstance({
    required String word,
    required LetterResultArray5 results,
  }) => RustLib.instance.api.crateApiWrdlHelperGuessResultNew(
    word: word,
    results: results,
  );

  @override
  int get hashCode => word.hashCode ^ results.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GuessResult &&
          runtimeType == other.runtimeType &&
          word == other.word &&
          results == other.results;
}

/// Intelligent solver that combines multiple algorithms for optimal word selection
class IntelligentSolver {
  const IntelligentSolver({required this.words});
  final List<String> words;

  /// Calculate entropy (information gain) for a candidate word
  ///
  /// BALANCED: Uses Shannon entropy - simple and effective
  /// Based on the working algorithm that achieved 96% success rate
  Future<double> calculateEntropy({
    required String candidateWord,
    required List<String> remainingWords,
  }) =>
      RustLib.instance.api.crateApiWrdlHelperIntelligentSolverCalculateEntropy(
        that: this,
        candidateWord: candidateWord,
        remainingWords: remainingWords,
      );

  /// Calculate statistical score based on letter frequency and position probability
  ///
  /// BALANCED: Simple and effective statistical analysis
  /// Based on the working algorithm that achieved 96% success rate
  Future<double> calculateStatisticalScore({
    required String candidateWord,
    required List<String> remainingWords,
  }) => RustLib.instance.api
      .crateApiWrdlHelperIntelligentSolverCalculateStatisticalScore(
        that: this,
        candidateWord: candidateWord,
        remainingWords: remainingWords,
      );

  /// Filter words based on guess results
  Future<List<String>> filterWords({
    required List<String> words,
    required List<GuessResult> guessResults,
  }) => RustLib.instance.api.crateApiWrdlHelperIntelligentSolverFilterWords(
    that: this,
    words: words,
    guessResults: guessResults,
  );

  /// Get the best guess using intelligent algorithms
  ///
  /// IMPROVED VERSION: Implements three advanced strategies:
  /// 1. Two-List "Hard Mode" Strategy - Smart choice between info gathering vs winning
  /// 2. Dynamic Candidate Selection - Focus on high-potential words only
  /// 3. Minimax Look-Ahead Score - Advanced endgame optimization
  Future<String?> getBestGuess({
    required List<String> remainingWords,
    required List<GuessResult> guessResults,
  }) => RustLib.instance.api.crateApiWrdlHelperIntelligentSolverGetBestGuess(
    that: this,
    remainingWords: remainingWords,
    guessResults: guessResults,
  );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create a new intelligent solver
  static Future<IntelligentSolver> newInstance({required List<String> words}) =>
      RustLib.instance.api.crateApiWrdlHelperIntelligentSolverNew(words: words);

  /// Simulate the guess pattern that would result from guessing against a target word
  Future<String> simulateGuessPattern({
    required String guess,
    required String target,
  }) => RustLib.instance.api
      .crateApiWrdlHelperIntelligentSolverSimulateGuessPattern(
        that: this,
        guess: guess,
        target: target,
      );

  /// Check if a word matches the given guess pattern
  Future<bool> wordMatchesPattern({
    required String word,
    required GuessResult guessResult,
  }) => RustLib.instance.api
      .crateApiWrdlHelperIntelligentSolverWordMatchesPattern(
        that: this,
        word: word,
        guessResult: guessResult,
      );

  @override
  int get hashCode => words.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is IntelligentSolver &&
          runtimeType == other.runtimeType &&
          words == other.words;
}

/// FFI-compatible enum for letter results
enum LetterResult { gray, yellow, green }

class LetterResultArray5 extends NonGrowableListView<LetterResult> {
  LetterResultArray5(this._inner)
    : assert(_inner.length == arraySize),
      super(_inner);

  LetterResultArray5.init(LetterResult fill)
    : this(List<LetterResult>.filled(arraySize, fill));
  static const arraySize = 5;

  @internal
  List<LetterResult> get inner => _inner;
  final List<LetterResult> _inner;
}
