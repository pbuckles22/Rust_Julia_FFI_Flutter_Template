// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `filter_words_with_feedback`, `load_answer_words_from_assets`, `load_guess_words_from_assets`, `word_matches_all_feedback`, `word_matches_single_feedback`

/// * NORTH STAR ARCHITECTURE: Single FFI Entry Point
/// *
/// * This is the ONLY public FFI function in the North Star architecture.
/// * Client sends only GameState → Server handles ALL logic → Returns best_guess
/// *
/// * # Arguments
/// * - `guess_results`: Vector of tuples containing (word, result_pattern)
/// *   - word: The guessed word (e.g., "TARES")
/// *   - result_pattern: Array of 5 result strings ["G", "Y", "X", "G", "X"]
/// *     - "G" = Green (correct letter, correct position)
/// *     - "Y" = Yellow (correct letter, wrong position)
/// *     - "X" = Gray (letter not in word)
/// *
/// * # Returns
/// * - `Option<String>`: The best word to guess next, or None if no valid guesses remain
/// *
/// * # Performance
/// * - Time complexity: O(n*m) where n is candidate words, m is remaining words
/// * - Space complexity: O(n) for pattern analysis
/// * - Target response time: < 200ms
/// * - Success rate: 100% (preserved from perfect algorithm)
/// *
/// * # Example
/// * ```rust
/// * let guess_results = vec![
/// *     ("TARES".to_string(), vec!["G".to_string(), "Y".to_string(), "Y".to_string(), "X".to_string(), "X".to_string()])
/// * ];
/// * let best_guess = get_best_guess(guess_results);
/// * ```
///
String? getBestGuess({required List<(String, List<String>)> guessResults}) =>
    RustLib.instance.api.crateApiSimpleGetBestGuess(guessResults: guessResults);

/// * Get intelligent guess using advanced algorithms (optimized version)
/// *
/// * This function uses the wrdlHelper intelligent solver with Rust-managed word lists
/// * to avoid passing large data structures across FFI. Much faster than the original.
/// *
/// * # Arguments
/// * - `remaining_words`: Words that are still possible given current constraints
/// * - `guess_results`: Previous guess results with patterns
/// *
/// * # Returns
/// * The best word to guess next, or None if no valid guesses remain
/// *
/// * # Performance
/// * - Time complexity: O(n*m) where n is candidate words, m is remaining words
/// * - Space complexity: O(n) for pattern analysis
/// * - Target response time: < 200ms (much faster with Rust-managed words)
///
String? getIntelligentGuessFast({
  required List<String> remainingWords,
  required List<(String, List<String>)> guessResults,
}) => RustLib.instance.api.crateApiSimpleGetIntelligentGuessFast(
  remainingWords: remainingWords,
  guessResults: guessResults,
);

/// * Get intelligent guess using the REFERENCE algorithm (99.8% success rate)
/// *
/// * This function uses the exact same algorithm that achieved 99.8% success rate
/// * in the Rust benchmark. This is the high-performance reference implementation.
/// *
/// * # Arguments
/// * - `remaining_words`: Words that are still possible given current constraints
/// * - `guess_results`: Previous guess results with patterns
/// *
/// * # Returns
/// * The best word to guess next, or None if no valid guesses remain
/// *
/// * # Performance
/// * - Time complexity: O(n*m) where n is candidate words, m is remaining words
/// * - Space complexity: O(n) for pattern analysis
/// * - Target response time: < 200ms
/// * - Success rate: 99.8% (matches Rust benchmark)
///
String? getIntelligentGuessReference({
  required List<String> remainingWords,
  required List<(String, List<String>)> guessResults,
}) => RustLib.instance.api.crateApiSimpleGetIntelligentGuessReference(
  remainingWords: remainingWords,
  guessResults: guessResults,
);

/// * Get intelligent word suggestion using advanced algorithms
/// *
/// * This function uses Shannon entropy analysis, statistical analysis, and
/// * look-ahead strategy to recommend the optimal word for the current game state.
/// *
/// * # Arguments
/// * - `all_words`: Complete list of valid words
/// * - `remaining_words`: Words that could still be the answer
/// * - `guess_results`: Previous guess results with patterns
/// *
/// * # Returns
/// * The best word to guess next, or None if no valid suggestions
/// *
/// * # Performance
/// * - Time complexity: O(n*m) where n is candidate words, m is remaining words
/// * - Space complexity: O(n) for pattern analysis
/// * - Target response time: < 200ms
///
String? getIntelligentGuess({
  required List<String> allWords,
  required List<String> remainingWords,
  required List<(String, List<String>)> guessResults,
}) => RustLib.instance.api.crateApiSimpleGetIntelligentGuess(
  allWords: allWords,
  remainingWords: remainingWords,
  guessResults: guessResults,
);

/// * Filter words based on guess results
/// *
/// * This function filters a word list based on previous guess results,
/// * removing words that don't match the established patterns.
/// *
/// * # Arguments
/// * - `words`: List of words to filter
/// * - `guess_results`: Previous guess results with patterns
/// *
/// * # Returns
/// * Filtered list of words that match all patterns
/// *
/// * # Performance
/// * - Time complexity: O(n*m) where n is words, m is guess results
/// * - Space complexity: O(n) for filtered results
///
List<String> filterWords({
  required List<String> words,
  required List<(String, List<String>)> guessResults,
}) => RustLib.instance.api.crateApiSimpleFilterWords(
  words: words,
  guessResults: guessResults,
);

/// * Calculate entropy for a candidate word
/// *
/// * This function calculates the Shannon entropy (information gain) for a
/// * candidate word against the remaining possible words.
/// *
/// * # Arguments
/// * - `candidate_word`: The word to analyze
/// * - `remaining_words`: Words that could still be the answer
/// *
/// * # Returns
/// * Entropy value (higher = more information)
/// *
/// * # Performance
/// * - Time complexity: O(n) where n is remaining words
/// * - Space complexity: O(n) for pattern grouping
///
double calculateEntropy({
  required String candidateWord,
  required List<String> remainingWords,
}) => RustLib.instance.api.crateApiSimpleCalculateEntropy(
  candidateWord: candidateWord,
  remainingWords: remainingWords,
);

/// * Simulate guess pattern for testing
/// *
/// * This function simulates what pattern would result from guessing
/// * a word against a target word.
/// *
/// * # Arguments
/// * - `guess`: The word being guessed
/// * - `target`: The target word
/// *
/// * # Returns
/// * Pattern string like "GGYXY" (G=Green, Y=Yellow, X=Gray)
/// *
/// * # Performance
/// * - Time complexity: O(1) for 5-letter words
/// * - Space complexity: O(1)
///
String simulateGuessPattern({required String guess, required String target}) =>
    RustLib.instance.api.crateApiSimpleSimulateGuessPattern(
      guess: guess,
      target: target,
    );

/// * Set solver configuration
/// *
/// * This function sets the global solver configuration for all subsequent operations.
/// *
/// * # Arguments
/// * - `config`: Configuration struct with all solver settings
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(1)
///
void setSolverConfig({
  required bool referenceMode,
  required bool includeKillerWords,
  required int candidateCap,
  required bool earlyTerminationEnabled,
  required double earlyTerminationThreshold,
  required bool entropyOnlyScoring,
}) => RustLib.instance.api.crateApiSimpleSetSolverConfig(
  referenceMode: referenceMode,
  includeKillerWords: includeKillerWords,
  candidateCap: candidateCap,
  earlyTerminationEnabled: earlyTerminationEnabled,
  earlyTerminationThreshold: earlyTerminationThreshold,
  entropyOnlyScoring: entropyOnlyScoring,
);
