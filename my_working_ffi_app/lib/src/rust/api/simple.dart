// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

import '../frb_generated.dart';

/// * Greet a user with a personalized message
/// *
/// * This function demonstrates basic string handling across the FFI boundary.
/// * It takes a name parameter and returns a formatted greeting string.
/// *
/// * # Arguments
/// * - `name`: The name of the person to greet
/// *
/// * # Returns
/// * A formatted greeting string
/// *
/// * # Example
/// * ```rust
/// * let greeting = greet("Alice".to_string());
/// * assert_eq!(greeting, "Hello, Alice!");
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(n) where n is the length of the name
///
String greet({required String name}) =>
    RustLib.instance.api.crateApiSimpleGreet(name: name);

/// * Add two integers and return the result
/// *
/// * Demonstrates basic arithmetic operations across the FFI boundary.
/// * This function showcases how to handle primitive types in FFI calls.
/// *
/// * # Arguments
/// * - `a`: First integer
/// * - `b`: Second integer
/// *
/// * # Returns
/// * The sum of a and b
/// *
/// * # Example
/// * ```rust
/// * let result = add_numbers(5, 3);
/// * assert_eq!(result, 8);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(1)
///
int? addNumbers({required int a, required int b}) =>
    RustLib.instance.api.crateApiSimpleAddNumbers(a: a, b: b);

/// * Multiply two floating-point numbers
/// *
/// * Demonstrates floating-point arithmetic across the FFI boundary.
/// * Useful for mathematical computations that need to be performed in Rust
/// * for performance reasons.
/// *
/// * # Arguments
/// * - `a`: First floating-point number
/// * - `b`: Second floating-point number
/// *
/// * # Returns
/// * The product of a and b
/// *
/// * # Example
/// * ```rust
/// * let result = multiply_floats(2.5, 4.0);
/// * assert_eq!(result, 10.0);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(1)
///
double multiplyFloats({required double a, required double b}) =>
    RustLib.instance.api.crateApiSimpleMultiplyFloats(a: a, b: b);

/// * Check if a number is even
/// *
/// * Demonstrates boolean return types across the FFI boundary.
/// * This function showcases conditional logic and boolean operations.
/// *
/// * # Arguments
/// * - `number`: The integer to check
/// *
/// * # Returns
/// * `true` if the number is even, `false` otherwise
/// *
/// * # Example
/// * ```rust
/// * assert!(is_even(4));
/// * assert!(!is_even(3));
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(1)
///
bool isEven({required int number}) =>
    RustLib.instance.api.crateApiSimpleIsEven(number: number);

/// * Get current timestamp as milliseconds since Unix epoch
/// *
/// * Demonstrates system time access across the FFI boundary.
/// * This function can be useful for logging, caching, or time-based operations.
/// *
/// * # Returns
/// * Current timestamp in milliseconds since Unix epoch
/// *
/// * # Example
/// * ```rust
/// * let timestamp = get_current_timestamp();
/// * assert!(timestamp > 0);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(1)
/// * - Space complexity: O(1)
/// *
/// * # Errors
/// * This function can panic if the system time is before Unix epoch,
/// * which is extremely unlikely in practice.
///
BigInt getCurrentTimestamp() =>
    RustLib.instance.api.crateApiSimpleGetCurrentTimestamp();

/// * Process a list of strings and return their lengths
/// *
/// * Demonstrates vector/array handling across the FFI boundary.
/// * This function showcases how to work with collections in FFI calls.
/// *
/// * # Arguments
/// * - `strings`: Vector of strings to process
/// *
/// * # Returns
/// * Vector of string lengths
/// *
/// * # Example
/// * ```rust
/// * let strings = vec!["hello".to_string(), "world".to_string()];
/// * let lengths = get_string_lengths(strings);
/// * assert_eq!(lengths, vec![5, 5]);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(n) where n is the number of strings
/// * - Space complexity: O(n) for the result vector
///
Uint32List getStringLengths({required List<String> strings}) =>
    RustLib.instance.api.crateApiSimpleGetStringLengths(strings: strings);

/// * Create a simple key-value mapping
/// *
/// * Demonstrates HashMap handling across the FFI boundary.
/// * This function showcases how to work with complex data structures in FFI calls.
/// *
/// * # Arguments
/// * - `pairs`: Vector of (key, value) tuples
/// *
/// * # Returns
/// * HashMap containing the key-value pairs
/// *
/// * # Example
/// * ```rust
/// * let pairs = vec![("name".to_string(), "Alice".to_string())];
/// * let map = create_string_map(pairs);
/// * assert_eq!(map.get("name"), Some(&"Alice".to_string()));
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(n) where n is the number of pairs
/// * - Space complexity: O(n) for the HashMap
///
Map<String, String> createStringMap({required List<(String, String)> pairs}) =>
    RustLib.instance.api.crateApiSimpleCreateStringMap(pairs: pairs);

/// * Calculate the factorial of a number
/// *
/// * Demonstrates recursive algorithms across the FFI boundary.
/// * This function showcases mathematical computations that can benefit
/// * from Rust's performance characteristics.
/// *
/// * # Arguments
/// * - `n`: The number to calculate factorial for (must be >= 0)
/// *
/// * # Returns
/// * The factorial of n
/// *
/// * # Example
/// * ```rust
/// * assert_eq!(factorial(5), 120);
/// * assert_eq!(factorial(0), 1);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(n)
/// * - Space complexity: O(n) due to recursion
/// *
/// * # Panics
/// * This function will panic if n is negative due to integer overflow.
/// * In a production environment, consider using a Result type instead.
///
int factorial({required int n}) =>
    RustLib.instance.api.crateApiSimpleFactorial(n: n);

/// * Check if a string is a palindrome
/// *
/// * Demonstrates string manipulation and algorithm implementation
/// * across the FFI boundary. This function showcases text processing
/// * capabilities that can be efficiently implemented in Rust.
/// *
/// * # Arguments
/// * - `text`: The string to check
/// *
/// * # Returns
/// * `true` if the string is a palindrome, `false` otherwise
/// *
/// * # Example
/// * ```rust
/// * assert!(is_palindrome("racecar".to_string()));
/// * assert!(!is_palindrome("hello".to_string()));
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(n) where n is the length of the string
/// * - Space complexity: O(1) for the optimized version
/// *
/// * # Note
/// * This implementation is case-sensitive and does not ignore whitespace.
/// * For a more robust implementation, consider normalizing the input.
///
bool isPalindrome({required String text}) =>
    RustLib.instance.api.crateApiSimpleIsPalindrome(text: text);

/// * Generate a simple hash for a string
/// *
/// * Demonstrates hashing algorithms across the FFI boundary.
/// * This function showcases cryptographic or data integrity operations
/// * that can be efficiently implemented in Rust.
/// *
/// * # Arguments
/// * - `input`: The string to hash
/// *
/// * # Returns
/// * A simple hash value as u32
/// *
/// * # Example
/// * ```rust
/// * let hash1 = simple_hash("hello".to_string());
/// * let hash2 = simple_hash("hello".to_string());
/// * assert_eq!(hash1, hash2);
/// * ```
/// *
/// * # Performance
/// * - Time complexity: O(n) where n is the length of the string
/// * - Space complexity: O(1)
/// *
/// * # Security Note
/// * This is a simple hash function for demonstration purposes.
/// * For cryptographic applications, use a proper hash function like SHA-256.
///
int simpleHash({required String input}) =>
    RustLib.instance.api.crateApiSimpleSimpleHash(input: input);
